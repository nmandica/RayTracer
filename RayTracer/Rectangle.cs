using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media.Media3D;

namespace RayTracer
{
    /// <summary>
    /// Rectangle class
    /// </summary>
    class Rectangle: Geometry
    {
        public readonly Point3D Point1;
        public readonly Point3D Point2;
        public readonly Point3D Point3;
        public readonly Point3D Point4;

        private Vector3D normal;

        /// <summary>
        /// Normal of the rectangle
        /// </summary>
        public Vector3D Normal
        {
            get
            {
                return normal;
            }
        }

        /// <summary>
        /// Width of this rectangle
        /// </summary>
        public double Width
        {
            get
            {
                Vector3D widthVector = Point2 - Point1;

                return widthVector.Length;
            }
        }

        /// <summary>
        /// Height of this rectangle
        /// </summary>
        public double Height
        {
            get
            {
                Vector3D heightVector = Point3 - Point2;

                return heightVector.Length;
            }
        }

        /// <summary>
        /// Default constructor. Throw exception if the given points do not form a rectangle.
        /// </summary>
        /// <param name="point1">First point</param>
        /// <param name="point2">Second point</param>
        /// <param name="point3">Third point</param>
        /// <param name="point4">Fourth point</param>
        [Newtonsoft.Json.JsonConstructor]
        public Rectangle(Point3D point1, Point3D point2, Point3D point3, Point3D point4)
        {
            if (!Rectangle.Exists(point1, point2, point3, point4))
            {
                throw new Exception();
            }

            Point1 = point1;
            Point2 = point2;
            Point3 = point3;
            Point4 = point4;

            normal = Vector3D.CrossProduct(Point2 - Point1, Point3 - Point2);
            normal.Normalize();
        }

        /// <summary>
        /// Constructor with 3 points. Throw exception if the given points cannot form a rectangle.
        /// </summary>
        /// <param name="point1">First point</param>
        /// <param name="point2">Second point</param>
        /// <param name="point3">Third point</param>
        public Rectangle(Point3D point1, Point3D point2, Point3D point3)
        {
            Point3D point4 = point1 + (point2 - point1) + (point3 - point1);
            if (!Rectangle.Exists(point1, point2, point3, point4))
            {
                point4 = point2 + (point1 - point2) + (point3 - point2);

                if (!Rectangle.Exists(point1, point2, point3, point4))
                {
                    point4 = point3 + (point1 - point3) + (point2 - point3);

                    if (!Rectangle.Exists(point1, point2, point3, point4))
                    {
                        throw new Exception();
                    }
                }
            }

            Point1 = point1;
            Point2 = point2;
            Point3 = point3;
            Point4 = point4;

            normal = Vector3D.CrossProduct(Point2 - Point1, Point3 - Point2);
            normal.Normalize();
        }

        /// <summary>
        /// Check if this rectangle exists
        /// </summary>
        /// <param name="point1">First point</param>
        /// <param name="point2">Second point</param>
        /// <param name="point3">Third point</param>
        /// <param name="point4">Fourth point</param>
        /// <returns>True if these points define a rectangle</returns>
        public static bool Exists(Point3D point1, Point3D point2, Point3D point3, Point3D point4)
        {
            bool exists = false;

            var normal = Vector3D.CrossProduct(point2 - point1, point3 - point2);
            var dotProduct = Vector3D.DotProduct(normal, point1 - point4);

            if (dotProduct.AboutEquals(0)) //point4 is in the plane generated by point1, point2 and point3
            {
                Vector3D vector1 = point2 - point1;
                Vector3D vector2 = point3 - point2;
                Vector3D vector3 = point4 - point3;
                Vector3D vector4 = point1 - point4;

                if (vector1.Length.AboutEquals(vector3.Length) && vector2.Length.AboutEquals(vector4.Length)) //It's a parallelogram
                {
                    var firstAngle = Vector3D.AngleBetween(vector1, vector2);

                    if (firstAngle.AboutEquals(90)) //One right angle. It's a rectangle
                    {
                        exists = true;
                    }
                }
            }

            return exists;
        }

        override public Vector3D GetSurfaceNormalAtPoint(Vector3D point) => Normal;

        /// <summary>
        /// Calculate the intesection point between the ray and the plane of the rectangle.
        /// </summary>
        /// <param name="ray">The ray to check</param>
        /// <param name="intersectionPoint">The result intersection point</param>
        /// <returns>True if the intersection is in the rectangle</returns>
        override public bool Intersects(Ray ray, ref Vector3D intersectionPoint)
        {
            var normalDotProduct = Vector3D.DotProduct(Normal, ray.Direction);
            // Do the intersection test as for a Plane.
            if (normalDotProduct != 0)
            {
                //Give the right orientation to the normal vector
                if (normalDotProduct > 0)
                {
                    normal = -Normal;
                }

                Vector3D Point = (Vector3D) Point1;
                double t = (Vector3D.DotProduct(Normal, (Vector3D.Subtract(Point, ray.Source)))) / (Vector3D.DotProduct(Normal, ray.Direction));

                if (t >= 0)
                {
                    intersectionPoint = ray.Source + (ray.Direction * t);

                    var alpha = Vector3D.DotProduct((Point3D) intersectionPoint - Point1, Point2 - Point1) / (Point2 - Point1).LengthSquared;
                    var beta = Vector3D.DotProduct((Point3D)intersectionPoint - Point1, Point4 - Point1) / (Point4 - Point1).LengthSquared;

                    if (alpha >= 0 && alpha <= 1 && beta >= 0 && beta <= 1)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
